--- /dev/null
+++ b/openwrt/target/linux/generic/patches-3.10/072-net-phy-Check-for-aneg-completion-before-setting-sta.patch
@@ -0,0 +1,35 @@
+From: Balakumaran Kannan <kumaran.4353@gmail.com>
+Date: Thu, 24 Apr 2014 08:22:47 +0530
+Subject: [PATCH] net phy: Check for aneg completion before setting state to
+ PHY_RUNNING
+
+phy_state_machine should check whether auto-negotiatin is completed
+before changing phydev->state from PHY_NOLINK to PHY_RUNNING. If
+auto-negotiation is not completed phydev->state should be set to
+PHY_AN.
+
+Signed-off-by: Balakumaran Kannan <kumaran.4353@gmail.com>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -805,6 +805,17 @@ void phy_state_machine(struct work_struc
+ 				break;
+
+ 			if (phydev->link) {
++				if (AUTONEG_ENABLE == phydev->autoneg) {
++					err = phy_aneg_done(phydev);
++					if (err < 0)
++						break;
++
++					if (!err) {
++						phydev->state = PHY_AN;
++						phydev->link_timeout = PHY_AN_TIMEOUT;
++						break;
++					}
++				}
+ 				phydev->state = PHY_RUNNING;
+ 				netif_carrier_on(phydev->attached_dev);
+ 				phydev->adjust_link(phydev->attached_dev);
--- /dev/null
+++ b/openwrt/target/linux/generic/patches-3.10/073-net-phy-resume-phydev-when-going-to-RESUMING.patch
@@ -0,0 +1,65 @@
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -743,7 +743,7 @@ void phy_state_machine(struct work_struc
+ 	struct delayed_work *dwork = to_delayed_work(work);
+ 	struct phy_device *phydev =
+ 			container_of(dwork, struct phy_device, state_queue);
+-	int needs_aneg = 0;
++	bool needs_aneg = false, do_suspend = false, do_resume = false;
+ 	int err = 0;
+
+ 	mutex_lock(&phydev->lock);
+@@ -758,7 +758,7 @@ void phy_state_machine(struct work_struc
+ 		case PHY_PENDING:
+ 			break;
+ 		case PHY_UP:
+-			needs_aneg = 1;
++			needs_aneg = true;
+
+ 			phydev->link_timeout = PHY_AN_TIMEOUT;
+
+@@ -791,7 +791,7 @@ void phy_state_machine(struct work_struc
+ 				phydev->adjust_link(phydev->attached_dev);
+
+ 			} else if (0 == phydev->link_timeout--) {
+-				needs_aneg = 1;
++				needs_aneg = true;
+ 				/* If we have the magic_aneg bit,
+ 				 * we try again */
+ 				if (phydev->drv->flags & PHY_HAS_MAGICANEG)
+@@ -832,7 +832,7 @@ void phy_state_machine(struct work_struc
+ 				netif_carrier_on(phydev->attached_dev);
+ 			} else {
+ 				if (0 == phydev->link_timeout--)
+-					needs_aneg = 1;
++					needs_aneg = true;
+ 			}
+
+ 			phydev->adjust_link(phydev->attached_dev);
+@@ -868,6 +868,7 @@ void phy_state_machine(struct work_struc
+ 				phydev->link = 0;
+ 				netif_carrier_off(phydev->attached_dev);
+ 				phydev->adjust_link(phydev->attached_dev);
++				do_suspend = true;
+ 			}
+ 			break;
+ 		case PHY_RESUMING:
+@@ -918,6 +919,7 @@ void phy_state_machine(struct work_struc
+ 					phydev->state = PHY_NOLINK;
+ 				phydev->adjust_link(phydev->attached_dev);
+ 			}
++			do_resume = true;
+ 			break;
+ 	}
+
+@@ -925,6 +927,10 @@ void phy_state_machine(struct work_struc
+
+ 	if (needs_aneg)
+ 		err = phy_start_aneg(phydev);
++	else if (do_suspend)
++		genphy_suspend(phydev);
++	else if (do_resume)
++		genphy_resume(phydev);
+
+ 	if (err < 0)
+ 		phy_error(phydev);
