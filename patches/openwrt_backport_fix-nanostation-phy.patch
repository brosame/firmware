Import von drei openwrt-Patches fuer Kernel v3.14:
* https://dev.openwrt.org/changeset/43757
* https://dev.openwrt.org/changeset/43776
siehe https://dev.openwrt.org/ticket/18616

Hoffentlich behebt dies die gelegentlichen eth0-Ausfaelle (siehe #94).
--- /dev/null
+++ b/openwrt/target/linux/generic/patches-3.10/072-net-phy-Check-for-aneg-completion-before-setting-sta.patch
@@ -0,0 +1,35 @@
+From: Balakumaran Kannan <kumaran.4353@gmail.com>
+Date: Thu, 24 Apr 2014 08:22:47 +0530
+Subject: [PATCH] net phy: Check for aneg completion before setting state to
+ PHY_RUNNING
+
+phy_state_machine should check whether auto-negotiatin is completed
+before changing phydev->state from PHY_NOLINK to PHY_RUNNING. If
+auto-negotiation is not completed phydev->state should be set to
+PHY_AN.
+
+Signed-off-by: Balakumaran Kannan <kumaran.4353@gmail.com>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -744,6 +744,17 @@ void phy_state_machine(struct work_struc
+ 			break;
+ 
+ 		if (phydev->link) {
++			if (AUTONEG_ENABLE == phydev->autoneg) {
++				err = phy_aneg_done(phydev);
++				if (err < 0)
++					break;
++
++				if (!err) {
++					phydev->state = PHY_AN;
++					phydev->link_timeout = PHY_AN_TIMEOUT;
++					break;
++				}
++			}
+ 			phydev->state = PHY_RUNNING;
+ 			netif_carrier_on(phydev->attached_dev);
+ 			phydev->adjust_link(phydev->attached_dev);
--- /dev/null
+++ b/openwrt/target/linux/generic/patches-3.10/073-net-phy-resume-phydev-when-going-to-RESUMING.patch
@@ -0,0 +1,72 @@
+siehe https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-3.14/073-net-phy-resume-phydev-when-going-to-RESUMING.patch?rev=43776
+
+dieser Patch behebt hoffentlich gelegentliche eth0-Ausfaelle auf loco-XW-Geraeten
+
+--- a/openwrt/drivers/net/phy/phy.c
++++ b/openwrt/drivers/net/phy/phy.c
+@@ -690,7 +690,7 @@ void phy_state_machine(struct work_struc
+ 	struct delayed_work *dwork = to_delayed_work(work);
+ 	struct phy_device *phydev =
+ 			container_of(dwork, struct phy_device, state_queue);
+-	int needs_aneg = 0, do_suspend = 0;
++	bool needs_aneg = false, do_suspend = false, do_resume = false;
+ 	int err = 0;
+ 
+ 	mutex_lock(&phydev->lock);
+@@ -702,7 +702,7 @@ void phy_state_machine(struct work_struc
+ 	case PHY_PENDING:
+ 		break;
+ 	case PHY_UP:
+-		needs_aneg = 1;
++		needs_aneg = true;
+ 
+ 		phydev->link_timeout = PHY_AN_TIMEOUT;
+ 
+@@ -732,7 +732,7 @@ void phy_state_machine(struct work_struc
+ 			phydev->adjust_link(phydev->attached_dev);
+ 
+ 		} else if (0 == phydev->link_timeout--) {
+-			needs_aneg = 1;
++			needs_aneg = true;
+ 			/* If we have the magic_aneg bit, we try again */
+ 			if (phydev->drv->flags & PHY_HAS_MAGICANEG)
+ 				break;
+@@ -770,7 +770,7 @@ void phy_state_machine(struct work_struc
+ 			netif_carrier_on(phydev->attached_dev);
+ 		} else {
+ 			if (0 == phydev->link_timeout--)
+-				needs_aneg = 1;
++				needs_aneg = true;
+ 		}
+ 
+ 		phydev->adjust_link(phydev->attached_dev);
+@@ -806,7 +806,7 @@ void phy_state_machine(struct work_struc
+ 			phydev->link = 0;
+ 			netif_carrier_off(phydev->attached_dev);
+ 			phydev->adjust_link(phydev->attached_dev);
+-			do_suspend = 1;
++			do_suspend = true;
+ 		}
+ 		break;
+ 	case PHY_RESUMING:
+@@ -855,6 +855,7 @@ void phy_state_machine(struct work_struc
+ 			}
+ 			phydev->adjust_link(phydev->attached_dev);
+ 		}
++		do_resume = true;
+ 		break;
+ 	}
+ 
+@@ -862,9 +863,10 @@ void phy_state_machine(struct work_struc
+ 
+ 	if (needs_aneg)
+ 		err = phy_start_aneg(phydev);
+-
+-	if (do_suspend)
++	else if (do_suspend)
+ 		phy_suspend(phydev);
++	else if (do_resume)
++		phy_resume(phydev);
+ 
+ 	if (err < 0)
+ 		phy_error(phydev);
--- /dev/null
+++ b/openwrt/target/linux/generic/patches-3.10/704-phy-no-genphy-soft-reset.patch
@@ -0,0 +1,29 @@
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -1102,7 +1102,7 @@ static int genphy_config_init(struct phy
+ 	return 0;
+ }
+ 
+-static int gen10g_soft_reset(struct phy_device *phydev)
++static int no_soft_reset(struct phy_device *phydev)
+ {
+ 	/* Do nothing for now */
+ 	return 0;
+@@ -1282,7 +1282,7 @@ static struct phy_driver genphy_driver[]
+ 	.phy_id		= 0xffffffff,
+ 	.phy_id_mask	= 0xffffffff,
+ 	.name		= "Generic PHY",
+-	.soft_reset	= genphy_soft_reset,
++	.soft_reset	= no_soft_reset,
+ 	.config_init	= genphy_config_init,
+ 	.features	= 0,
+ 	.config_aneg	= genphy_config_aneg,
+@@ -1294,7 +1294,7 @@ static struct phy_driver genphy_driver[]
+ 	.phy_id         = 0xffffffff,
+ 	.phy_id_mask    = 0xffffffff,
+ 	.name           = "Generic 10G PHY",
+-	.soft_reset	= gen10g_soft_reset,
++	.soft_reset	= no_soft_reset,
+ 	.config_init    = gen10g_config_init,
+ 	.features       = 0,
+ 	.config_aneg    = gen10g_config_aneg,
