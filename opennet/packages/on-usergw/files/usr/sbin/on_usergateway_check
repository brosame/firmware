#!/bin/sh
#
# Opennet Firmware
# 
# Copyright 2010 Rene Ejury <opennet@absorb.it>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 

# Debug?
# set -x
set -u

# include helper functions
. "${IPKG_INSTROOT:-}/usr/lib/opennet/on-helper.sh"

DATA_LOCK_FILE=/var/run/on_usergateway_check
VPN_DIR_TEST=/etc/openvpn/opennet_vpntest


#################################################################################
# Geschwindigkeitsmessung gegen die konfigurierten UGWs
# Eintragen der Ergebnisse in die Status-Datei fuer UGWs.
# $1=nr
ugw_checkSpeed () {
	trap "error_trap ugw_checkSpeed $*" $GUARD_TRAPS
	echo "ugw_checkSpeed" >"$DATA_LOCK_FILE"
	local on_ugw=$(uci_get "on-usergw.opennet_ugw${1}.name")
	local ipaddr=$(uci_get "on-usergw.opennet_ugw${1}.ipaddr")
	local download_speed=$(measure_download_speed "$on_ugw")
	local upload_speed=$(measure_upload_speed "$on_ugw")
	# no checks if no number is available
	[ -z "$download_speed" ] && [ -z "$upload_speed" ] && return
	local prev_download=$(get_ugw_value "$ipaddr" download)
	local prev_upload=$(get_ugw_value "$ipaddr" upload)
	[ -z "$prev_download" -o "$prev_download" = "0" ] && set_ugw_value "$ipaddr" download "$download_speed"
	[ -z "$prev_upload" -o "$prev_upload" = "0" ] && set_ugw_value "$ipaddr" upload "$upload_speed"
	if [ -n "$prev_download" ] && [ "$prev_download" != "0" ] &&
			[ -n "$prev_upload" ] && [ "$prev_upload" != "0" ]; then
		set_ugw_value "$ipaddr" download "$(((download_speed+prev_download)/2))"
		set_ugw_value "$ipaddr" upload "$(((download_speed+prev_upload)/2))"
		# no significant change? Keep previous timestamp.
		if [ "$((download_speed/1000))" = "$((prev_download/1000))" ] && [ "$((upload_speed/1000))" = "$((prev_upload/1000))" ]; then
			set_ugw_value "$ipaddr" speed_time_prev "$(get_ugw_value "$ipaddr" speed_time)"
		fi
	fi
	set_ugw_value "$ipaddr" speed_time "$(date +%s)"
}

#################################################################################
get_prefixed_items() {
	local prefix="$1"
	local nr=1
	while uci_get "$prefix$nr" >/dev/null; do echo "$((nr++))"; done
}

#################################################################################
# check all stored Usergateways for speed
ugw_checkSpeeds () {
	local test_id
	msg_debug "ugw_checkSpeeds"
	for test_id in $(get_prefixed_items 'on-usergw.opennet_ugw'); do ugw_checkSpeed "$test_id"; done
}

#################################################################################
# try to establish openvpn tunnel
# return a string, if it works (else return nothing)
# parameter is index to test
ugw_checkVPN()
{
	trap "error_trap ugw_checkVPN $*" $GUARD_TRAPS
	echo "ugw_checkVPN" >"$DATA_LOCK_FILE"
	local uci_prefix=on-usergw.opennet_ugw$1
	local gw_ipaddr=$(uci_get "$uci_prefix.ipaddr")
	local gw_name=$(uci_get "$uci_prefix.name")
	# if no age set yet than set to recheck_age to force immediate testing
	local age=$(get_ugw_value "$gw_ipaddr" age)
	if [ -n "$age" ]; then
		# it's running every 5 minutes
		age=$((age+5))
	else
		age=$recheck_age
	fi
	set_ugw_value "$gw_ipaddr" age "$age"

	if [ "$age" -ge "$((recheck_age+nonworking_timeout))" ]; then
		# if there was no vpn-availability for a dedicated time (nonworking_timeout minutes), declare vpn-status as not working
		set_ugw_value "$gw_ipaddr" status n
		set_ugw_value "$gw_ipaddr" age 0
	elif [ $age -ge $recheck_age ]; then
		if verify_vpn_connection "$gw_ipaddr" "$gw_name" \
				"$VPN_DIR_TEST/on_aps.key" \
				"$VPN_DIR_TEST/on_aps.crt" \
				"$VPN_DIR_TEST/opennet-ca.crt"; then
			set_ugw_value "$gw_ipaddr" status y
			set_ugw_value "$gw_ipaddr" age 0
			msg_debug "vpn-availability of gw $gw_ipaddr successfully tested"
		fi
		msg_debug "finished vpn test of $gw_ipaddr"
	elif [ "$(get_ugw_value "$gw_ipaddr" status)" = "y" ]; then
		msg_debug "vpn-availability of gw $1 still valid"
	fi
}

#################################################################################
# check all stored Usergateways for working VPN (on port 1600)
ugw_checkVPNs () {
	local nr
	local ipaddr
	msg_debug "ugw_checkVPNs"
	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do
		ipaddr=$(uci_get "on-usergw.opennet_ugw${nr}.ipaddr")
		# do VPNchecks only if WAN-Connection is established
		if [ "$(get_ugw_value "$ipaddr" wan)" != "ok" ]; then
			msg_info "ugw_checkVPNs skipped for gw $nr ($ipaddr), not connected trough WAN"
		else
			ugw_checkVPN "$nr"
		fi
		: $((nr++))
	done
}


#################################################################################
# 
# 
ugw_getMTU () {
	trap "error_trap ugw_getMTU $*" $GUARD_TRAPS
	local remote=$1
	local rport=$(uci_get on-usergw.opennet_ugw.rport)
	local ca=$(uci_get on-usergw.opennet_ugw.ca)
	local cert=$(uci_get on-usergw.opennet_ugw.cert)
	local key=$(uci_get on-usergw.opennet_ugw.key)
	[ ! -e "$cert" ] && msg_debug "Skipping ugw_getMTU due to missing certificacte" && return 0
	local pidfile="/tmp/openvpn_mtutest_$$.pid"
	local outfile="/tmp/openvpn_mtutest_$$.out"
	local openvpn_ugw_test_parameters="--mtu-test --remote $remote $rport --tls-client --ns-cert-type server \
		--ca $ca --cert $cert --key $key --dev tap_mtu --inactive 10 --nice 3 \
		--resolv-retry 0 --ping-exit 25 --ping-restart 0 --comp-lzo --tls-exit --writepid $pidfile"

	# for external debugging
	echo "$openvpn_ugw_test_parameters" >/tmp/openvpn_ugw_test_parameters

	openvpn $openvpn_ugw_test_parameters >"$outfile" 2>&1 &
	# wait for openvpn to startup and write pid file
	sleep 10
	local pid=$(cat "$pidfile")
	local wait_loops=20
	local mtu_out
	while [ "$wait_loops" -gt 0 ]; do
		# wait for one minute
		sleep 30	
		mtu_out=$(grep "MTU test completed" "$outfile")
		# for example 
		# Thu Jul  3 22:23:01 2014 NOTE: Empirical MTU test completed [Tried,Actual] local->remote=[1573,1573] remote->local=[1573,1573]
		if [ -n "$mtu_out" ]; then
                        # output result as one line 4 numbers and complete status output line comma separated
			echo "$mtu_out" | tr '[' ',' | tr ']' ',' | cut -d , -f 5,6,8,9 | tr '\n' ',' 
			echo "$mtu_out"
			kill "$pid" >/dev/null 2>&1 || true ; rm -f "$pidfile" "$outfile"
			return 0
		fi
		if [ ! -d "/proc/$pid" ]; then
			msg_info "test for ugw_checkMTU $remote impossible. Aborting."
			kill "$pid" >/dev/null 2>&1 || true ; rm -f "$pidfile" "$outfile"
			trap "" $GUARD_TRAPS && return 1
		fi
		: $((wait_loops--))
	done
	# timer run off, kill leftover openvpn and abort test
	kill "$pid" >/dev/null 2>&1 || true
	rm -f "$pidfile" "$outfile"
	msg_info "timeout for ugw_checkMTU $remote. Aborting."
	trap "" $GUARD_TRAPS && return 1
}

#################################################################################
# if ugw has some broken MTU settings, traffic will not go through the gateway
# even if olsrd or icmp-packages are working well. Therefore check MTU before
# recognizing a ugw as working...
# $1=nr
ugw_checkMTU () {
	trap "error_trap ugw_checkMTU $*" $GUARD_TRAPS
	local uci_prefix=on-usergw.opennet_ugw$1
	local ipaddr=$(uci_get "${uci_prefix}.ipaddr" ipaddr)
	echo "ugw_checkMTU" >"$DATA_LOCK_FILE"
	if [ "$(get_ugw_value "$ipaddr" wan)" != "ok" ]; then
		msg_debug "ugw_checkMTU for ugw$1 skipped, please check WAN first"
		return
	fi
	
	remote=$(uci_get "${uci_prefix}.name")
	msg_debug "starting ugw_checkMTU for ugw${1}, $remote"
	msg_debug "ugw_checkMTU will take around 5 minutes per gateway"

	local result=$(ugw_getMTU "$remote")

	if [ -n "$result" ]; then
		local toGW_tried=$(echo "$result" | cut -f 1 -d ,)
		local toGW_actual=$(echo "$result" | cut -f 2 -d ,)
		local fromGW_tried=$(echo "$result" | cut -f 3 -d ,)
		local fromGW_actual=$(echo "$result" | cut -f 4 -d ,)
		local status_output=$(echo "$result" | cut -f 5- -d ,)
	
		if [ "$toGW_tried" -le "$toGW_actual" ] && [ "$fromGW_tried" -le "$fromGW_actual" ]; then
			set_ugw_value "$ipaddr" mtu ok
		else
			set_ugw_value "$ipaddr" mtu error
		fi

		set_ugw_value "$ipaddr" mtu_msg "$status_output"
		set_ugw_value "$ipaddr" mtu_toGW_tried "$toGW_tried"
		set_ugw_value "$ipaddr" mtu_toGW_actual "$toGW_actual"
		set_ugw_value "$ipaddr" mtu_fromGW_tried "$fromGW_tried"
		set_ugw_value "$ipaddr" mtu_fromGW_actual "$fromGW_actual"
		set_ugw_value "$ipaddr" mtu_time "$(date +%s)"
	fi

	local mtu=$(get_ugw_value "$ipaddr" mtu)
	local mtu_msg=$(get_ugw_value "$ipaddr" mtu_msg)
	msg_debug "$mtu: ugw_checkMTU for ugw${1}, $remote done"
	msg_debug "$mtu: $mtu_msg"
}

#################################################################################
# check all stored Usergateways for working MTU
ugw_checkMTUs () {
	msg_debug "ugw_checkMTUs"
	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do ugw_checkMTU "$nr"; done
}


# Pruefung ob der Verkehr zu einem UGW ueber ein WAN-Interface verlaufen wuerde
# Falls nicht, dann wird das "wan"-Flag auf "error" gesetzt.
ugw_checkWAN () {
	trap "error_trap ugw_checkWAN $*" $GUARD_TRAPS
	echo "ugw_checkWAN" >"$DATA_LOCK_FILE"
	local config_name=$1
	local uci_prefix=$(find_first_uci_section on-usergw uplink "name=$config_name")
	local hostname=$(uci_get "${uci_prefix}.hostname")
	local on_ugw_targetDev
	on_ugw_targetDev=$(get_target_route_interface "$hostname")
	if is_interface_in_zone "$on_ugw_targetDev" "wan"; then
		set_ugw_value "$config_name" wan ok
		time=$(ping -w 5 -q "$hostname" 2>/dev/null| awk 'BEGIN{FS="[ \/]+"} /min\/avg\/max/ {print int($7+0.5)}')
		set_ugw_value "$config_name" ping "$time"
		msg_debug "checkWAN: $hostname routing through wan device: $on_ugw_targetDev"
		msg_debug "checkWAN: $hostname avg ping time: $time"
	else
		set_ugw_value "$config_name" wan error
		set_ugw_value "$config_name" ping "$time" ""
	fi
}

#################################################################################
# check all stored Usergateways for working MTU
ugw_checkWANs () {
	local uci_prefix
	local config_name
	msg_debug "ugw_checkWANs"
	find_all_uci_sections on-usergw uplink "type=openvpn" | while read uci_prefix; do
		config_name=$(uci_get "${uci_prefix}.name")
		ugw_checkWAN "$config_name"
	done
}


#################################################################################
# check if sharingInternet is temporarily blocked
ugw_checkSharingBlocked () {
	trap "error_trap ugw_checkSharingBlocked $*" $GUARD_TRAPS
	local on_share_internet_unblock_time=$(on-usergw.ugw_sharing.unblock_time)
	[ -z "$on_share_internet_unblock_time" ] && return
	if [ "$(date +%s)" -gt "$on_share_internet_unblock_time" ]; then
		uci_delete on-usergw.ugw_sharing.unblock_time
		uci set on-usergw.ugw_sharing.shareInternet='on'
	elif [ "$(uci_get on-usergw.ugw_sharing.shareInternet)" = "on" ]; then
		uci set on-usergw.ugw_sharing.shareInternet='off'
	fi
}

#################################################################################
# check if sharingInternet is possible for every gateway and
# store 'enable'-value in openvpn config
ugw_checkWorking () {
	local uci_prefix
	local config_name
	local mtu
	local wan
	local name
	local enable
	trap "error_trap ugw_checkWorking $*" $GUARD_TRAPS
	find_all_uci_sections on-usergw uplink "type=openvpn" | while read uci_prefix; do
		config_name=$(uci_get "${uci_prefix}.name")
		mtu=$(get_ugw_value "$config_name" mtu)
		wan=$(get_ugw_value "$config_name" wan)

		enable=$(uci_get "openvpn.${config_name}.enable")
		[ -z "$enable" ] && enable=1

		if [ "$mtu" = "ok" ] && [ "$wan" = "ok" ] && uci_is_false "$enable"; then
			enable_ugw_service "$config_name"
		elif [ "$mtu" != "ok" -o "$wan" != "ok" ] && uci_is_true "$enable"; then
			disable_ugw_service "$config_name"
		fi
	done
	apply_changes on-usergw
}

#################################################################################
# check if sharingInternet is enabled and tunnels are active or vice versa
ugw_shareInternet () {
	trap "error_trap ugw_shareInternet $*" $GUARD_TRAPS
	local config_name
	local enable

	sharing="$(uci_get on-usergw.ugw_sharing.shareInternet)"
	[ -z "$sharing" ] && sharing=0
	find_all_uci_sections on-usergw uplink "type=openvpn" | while read uci_prefix; do
		config_name=$(uci_get "${uci_prefix}.name")
		enable=$(uci_get openvpn.${config_name}.enable)
		[ -z "$enable" ] && enable=1

		if [ ! -e "/var/run/openvpn-${config_name}.pid" ] && uci_is_true "$sharing" && uci_is_true "$enable"; then
			msg_info "activating tunnel ${config_name}"
			enable_ugw_service "$config_name"
		elif [ -e /var/run/openvpn-${config_name}.pid ] && ( uci_is_false "$sharing" || uci_is_false "$enable" ); then
			msg_info "disabling tunnel ${config_name}"
			disable_ugw_service "$config_name"
		fi
		apply_changes on-usergw
	done
}


#################################################################################
# do extra checks (speed, mtu) only at dedicated times
ugw_doExtraChecks () {
	trap "error_trap ugw_doExtraChecks $*" $GUARD_TRAPS
	msg_debug "ugw_doExtraChecks"
	local nr
	local speed_time
	local speed_time_prev
	local name
	local gw_name
	local vpn_pid
	local mtu_time
	local config_name
	local restart_time=$(($(date +%s)-$(cut -f1 -d. /proc/uptime)))

	find_all_uci_sections on-usergw uplink | while read uci_prefix; do
		config_name=$(uci_get "${uci_prefix}.name")
		# do extraChecks only if WAN-Connection is established
		[ "$(get_ugw_value "$config_name" "wan")" != "ok" ] && continue

		# speedCheck
		speed_time=$(get_ugw_value "$config_name" "speed_time")
		[ -z "$speed_time" ] && speed_time=0
		# never checked since restart
		if [ "$((speed_time-restart_time))" -lt 0 ]; then
			set_ugw_value "$config_name" "speed_time" ""
			set_ugw_value "$config_name" "speed_time_prev" ""
		fi
		speed_time=$(get_ugw_value "$config_name" "speed_time")
		speed_time_prev=$(get_ugw_value "$config_name" "speed_time_prev")
		if [ -z "$speed_time" ] ||
				# last (successful) check older than 1 day and no two successful checks had been done
				( [ "$(($(date +%s)-speed_time))" -gt 86400 ] && [ -z "$speed_time_prev" ] ); then
			ugw_checkSpeed "$config_name"
		fi

		# mtuCheck
		# if last mtucheck is older than 1 day and ugw is not running
		vpn_pid=$(cat "/var/run/openvpn-${config_name}.pid" 2>/dev/null)
		mtu_time=$(get_ugw_value "$config_name" "mtu_time")
		[ -z "$vpn_pid" -o ! -d "/proc/$vpn_pid" ] && [ "$(($(date +%s)-mtu_time))" -gt 86400 ] && ugw_checkMTU "$config_name"
	done
}

#################################################################################
# values are equal to minutes (check is usually done every 5 minutes)
# time after the gateway is switched when found not working in minutes
betterusergateway_timeout=$(get_on_usergw_default vpn_bettergateway_timeout)

# after how many times gateway-vpn-function should rechecked
recheck_age=$(get_on_usergw_default vpn_recheck_age)

# how often it will be tried to establish a connection till gateway is declared as not to work
nonworking_timeout=$(get_on_usergw_default vpn_nonworking_timeout)

#################################################################################
# start here - with the menu
ACTION="${1:-auto}"
shift

test "$ACTION" = "--help" && echo -e "\
Usage: on_usergateway_check [OPTION]...
	usually called by cron every 5 minutes
Options:
	(no option)	do regular 5-minutely check
	checkWan	check if routes to UGW go through WAN-device, detect ping-time
	checkMtu	check if MTU of WAN-UGW-Tunnel is ok
			this test will last ~5 minutes per tunnel
			results will be stored in on-usergw config
	checkVpn	check Vpn availability of gateway on port 1600
	checkSpeed	check Speed of Gateway
	shareInternet	start UGW-tunnels if MTU and WAN ok and sharing is enabled
	--help		this help" && exit 0

aquire_lock "$DATA_LOCK_FILE" 600 || { msg_debug "parallel instance running, exit" && exit; }
echo "running" >"$DATA_LOCK_FILE"
msg_debug "starting another instance ($@)"


case "$ACTION" in
	"checkWan")		if [ $# -gt 0]; then ugw_checkWAN "$@"; else ugw_checkWANs; fi;;
	"checkMtu")		if [ $# -gt 0]; then ugw_checkMTU "$@"; else ugw_checkMTUs; fi;;
	"checkVpn")		if [ $# -gt 0]; then ugw_checkVPN "$@"; else ugw_checkVPNs; fi;;
	"checkSpeed")		if [ $# -gt 0]; then ugw_checkSpeed "$@"; else ugw_checkSpeeds; fi;;
	"shareInternet")
		ugw_checkSharingBlocked
		ugw_checkWorking
		update_ugw_service_state
		ugw_shareInternet
		;;
	auto|*)
		ugw_checkWANs
		ugw_checkVPNs
		ugw_doExtraChecks
		ugw_checkSharingBlocked
		ugw_checkWorking
		update_ugw_service_state
		ugw_shareInternet
		;;
esac

#################################################################################
# commit changes, otherwise they will slow down the whole system significantly
uci commit on-usergw

rm -f "$DATA_LOCK_FILE"
msg_debug "finishing another instance"

