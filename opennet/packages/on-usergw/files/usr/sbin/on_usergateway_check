#!/bin/sh
#
# Opennet Firmware
# 
# Copyright 2010 Rene Ejury <opennet@absorb.it>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 

# Debug?
# set -x
set -u

# include helper functions
. "${IPKG_INSTROOT:-}/usr/lib/opennet/on-helper.sh"

DATA_LOCK_FILE=/var/run/on_usergateway_check
VPN_DIR_TEST=/etc/openvpn/opennet_vpntest


#################################################################################
# Verkuende den lokalen UGW-Dienst inkl. Geschwindigkeitsdaten via olsr nameservice
# Parameter: die aktuell announcierte HNA-Adresse des lokalen UGW
announce_ugw_service_ugw() {
	trap "error_trap announce_ugw_service_ugw $*" $GUARD_TRAPS
	local uci_prefix=
	local gw_found=
	local index=0
	local hna="$1"
	local current_ugw_ipaddr=$(get_ugw_portforward | cut -f 2)
	[ -z "$current_ugw_ipaddr" ] && return

	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do
		if [ "$(uci_get "on-usergw.opennet_ugw${nr}.ipaddr")" = "$current_ugw_ipaddr" ]; then
			gw_found=true
			break
		fi
	done
	[ -z "$gw_found" ] && return

	local download=$(ugw_status get_ugw_flag "$current_ugw_ipaddr" download)
	local upload=$(ugw_status get_ugw_flag "$current_ugw_ipaddr" upload)
	local ping=$(ugw_status get_ugw_flag "$current_ugw_ipaddr" ping)

	local uci_prefix=$(get_and_enable_olsrd_library_uci_prefix "nameservice")
	[ -z "$uci_prefix" ] && msg_info "FATAL ERROR: failed to enforce olsr nameservice plugin" && trap "" $GUARD_TRAPS && return 1

	# announce our ugw service
	uci set "${uci_prefix}.service=http://${hna}:8080|tcp|ugw upload:$upload download:$download ping:$ping"

	# commit and restart olsrd if necessary
	apply_changes olsrd
}

#################################################################################
# check Usergateway for speed
# $1=nr
ugw_checkSpeed () {
	trap "error_trap ugw_checkSpeed $*" $GUARD_TRAPS
	echo "ugw_checkSpeed" >"$DATA_LOCK_FILE"
	. "${IPKG_INSTROOT:-}/usr/sbin/on_speed_check"
	local on_ugw=$(uci_get "on-usergw.opennet_ugw${1}.name")
	local ipaddr=$(uci_get "on-usergw.opennet_ugw${1}.ipaddr")
	local download_speed=$(download "$on_ugw")
	local upload_speed=$(upload "$on_ugw")
	# no checks if no number is available
	[ -z "$download_speed" ] && [ -z "$upload_speed" ] && return
	local prev_download=$(ugw_status get_ugw_flag "$ipaddr" download)
	local prev_upload=$(ugw_status get_ugw_flag "$ipaddr" upload)
	[ -z "$prev_download" -o "$prev_download" = "0" ] && ugw_status set_ugw_flag "$ipaddr" download "$download_speed"
	[ -z "$prev_upload" -o "$prev_upload" = "0" ] && ugw_status set_ugw_flag "$ipaddr" upload "$upload_speed"
	if [ -n "$prev_download" ] && [ "$prev_download" != "0" ] &&
			[ -n "$prev_upload" ] && [ "$prev_upload" != "0" ]; then
		ugw_status set_ugw_flag "$ipaddr" download "$(((download_speed+prev_download)/2))"
		ugw_status set_ugw_flag "$ipaddr" upload "$(((download_speed+prev_upload)/2))"
		# no significant change? Keep previous timestamp.
		if [ "$((download_speed/1000))" = "$((prev_download/1000))" ] && [ "$((upload_speed/1000))" = "$((prev_upload/1000))" ]; then
			ugw_status set_ugw_flag "$ipaddr" speed_time_prev "$(ugw_status get_ugw_flag "$ipaddr" speed_time)"
		fi
	fi
	ugw_status set_ugw_flag "$ipaddr" speed_time "$(date +%s)"
}

#################################################################################
get_prefixed_items() {
	local prefix="$1"
	local nr=1
	while uci_get "$prefix$nr" >/dev/null; do echo "$((nr++))"; done
}

#################################################################################
# check all stored Usergateways for speed
ugw_checkSpeeds () {
	local test_id
	msg_debug "ugw_checkSpeeds"
	for test_id in $(get_prefixed_items 'on-usergw.opennet_ugw'); do ugw_checkSpeed "$test_id"; done
}

#################################################################################
# try to establish openvpn tunnel
# return a string, if it works (else return nothing)
# parameter is index to test
ugw_checkVPN()
{
	trap "error_trap ugw_checkVPN $*" $GUARD_TRAPS
	echo "ugw_checkVPN" >"$DATA_LOCK_FILE"
	local uci_prefix=on-usergw.opennet_ugw$1
	local gw_ipaddr=$(uci_get "$uci_prefix.ipaddr")
	local gw_name=$(uci_get "$uci_prefix.name")
	# if no age set yet than set to recheck_age to force immediate testing
	local age=$(get_ugw_value "$gw_ipaddr" age)
	if [ -n "$age" ]; then
		# it's running every 5 minutes
		age=$((age+5))
	else
		age=$recheck_age
	fi
	set_ugw_value "$gw_ipaddr" age "$age"

	if [ "$age" -ge "$((recheck_age+nonworking_timeout))" ]; then
		# if there was no vpn-availability for a dedicated time (nonworking_timeout minutes), declare vpn-status as not working
		set_ugw_value "$gw_ipaddr" status n
		set_ugw_value "$gw_ipaddr" age 0
	elif [ $age -ge $recheck_age ]; then
		if verify_vpn_connection "$gw_ipaddr" "$gw_name" \
				"$VPN_DIR_TEST/on_aps.key" \
				"$VPN_DIR_TEST/on_aps.crt" \
				"$VPN_DIR_TEST/opennet-ca.crt"; then
			set_ugw_value "$gw_ipaddr" status y
			set_ugw_value "$gw_ipaddr" age 0
			msg_debug "vpn-availability of gw $gw_ipaddr successfully tested"
		fi
		msg_debug "finished vpn test of $gw_ipaddr"
	elif [ "$(get_ugw_value "$gw_ipaddr" status)" = "y" ]; then
		msg_debug "vpn-availability of gw $1 still valid"
	fi
}

#################################################################################
# check all stored Usergateways for working VPN (on port 1600)
ugw_checkVPNs () {
	local nr
	msg_debug "ugw_checkVPNs"
	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do
		# do VPNchecks only if WAN-Connection is established
		if [ "$(uci_get "on-usergw.opennet_ugw${nr}.wan")" != "ok" ]; then
			msg_info "ugw_checkVPNs skipped for gw $((nr++)), not connected trough WAN"
		else
			ugw_checkVPN "$((nr++))"
		fi
	done
}


#################################################################################
# 
# 
ugw_getMTU () {
	trap "error_trap ugw_getMTU $*" $GUARD_TRAPS
	local remote=$1
	local rport=$(uci_get on-usergw.opennet_ugw.rport)
	local ca=$(uci_get on-usergw.opennet_ugw.ca)
	local cert=$(uci_get on-usergw.opennet_ugw.cert)
	local key=$(uci_get on-usergw.opennet_ugw.key)
	local pidfile="/tmp/openvpn_mtutest_$$.pid"
	local outfile="/tmp/openvpn_mtutest_$$.out"
	local openvpn_ugw_test_parameters="--mtu-test --remote $remote $rport --tls-client --ns-cert-type server \
		--ca $ca --cert $cert --key $key --dev tap_mtu --inactive 10 --nice 3 \
		--resolv-retry 0 --ping-exit 25 --ping-restart 0 --comp-lzo --tls-exit --writepid $pidfile"

	# for external debugging
	echo "$openvpn_ugw_test_parameters" >/tmp/openvpn_ugw_test_parameters

	openvpn $openvpn_ugw_test_parameters >"$outfile" 2>&1 &
	# wait for openvpn to startup and write pid file
	sleep 10
	local pid=$(cat "$pidfile")
	local wait_loops=20
	local mtu_out
	while [ "$wait_loops" -gt 0 ]; do
		# wait for one minute
		sleep 30	
		mtu_out=$(grep "MTU test completed" "$outfile")
		# for example 
		# Thu Jul  3 22:23:01 2014 NOTE: Empirical MTU test completed [Tried,Actual] local->remote=[1573,1573] remote->local=[1573,1573]
		if [ -n "$mtu_out" ]; then
                        # output result as one line 4 numbers and complete status output line comma separated
			echo "$mtu_out" | tr '[' ',' | tr ']' ',' | cut -d , -f 5,6,8,9 | tr '\n' ',' 
			echo "$mtu_out"
			kill "$pid" >/dev/null 2>&1 || true ; rm -f "$pidfile" "$outfile"
			return 0
		fi
		if [ ! -d "/proc/$pid" ]; then
			msg_info "test for ugw_checkMTU $remote impossible. Aborting."
			kill "$pid" >/dev/null 2>&1 || true ; rm -f "$pidfile" "$outfile"
			trap "" $GUARD_TRAPS && return 1
		fi
		: $((wait_loops--))
	done
	# timer run off, kill leftover openvpn and abort test
	kill "$pid" >/dev/null 2>&1 || true
	rm -f "$pidfile" "$outfile"
	msg_info "timeout for ugw_checkMTU $remote. Aborting."
	trap "" $GUARD_TRAPS && return 1
}

#################################################################################
# if ugw has some broken MTU settings, traffic will not go through the gateway
# even if olsrd or icmp-packages are working well. Therefore check MTU before
# recognizing a ugw as working...
# $1=nr
ugw_checkMTU () {
	trap "error_trap ugw_checkMTU $*" $GUARD_TRAPS
	echo "ugw_checkMTU" >"$DATA_LOCK_FILE"
	if [ "$(uci_get "on-usergw.opennet_ugw${1}.wan")" != "ok" ]; then
		msg_debug "ugw_checkMTU for ugw$1 skipped, please check WAN first"
		return
	fi
	
	remote=$(uci_get on-usergw.opennet_ugw${1}.name)
	msg_debug "starting ugw_checkMTU for ugw${1}, $remote"
	msg_debug "ugw_checkMTU will take around 5 minutes per gateway"

	local result=$(ugw_getMTU "$remote")

	if [ -n "$result" ]; then
		local toGW_tried=$(echo "$result" | cut -f 1 -d ,)
		local toGW_actual=$(echo "$result" | cut -f 2 -d ,)
		local fromGW_tried=$(echo "$result" | cut -f 3 -d ,)
		local fromGW_actual=$(echo "$result" | cut -f 4 -d ,)
		local status_output=$(echo "$result" | cut -f 5- -d ,)
	
		if [ "$toGW_tried" -le "$toGW_actual" ] && [ "$fromGW_tried" -le "$fromGW_actual" ]; then
			uci -q set "on-usergw.opennet_ugw${1}.mtu=ok"
		else
			uci -q set "on-usergw.opennet_ugw${1}.mtu=error"
		fi

		uci -q set "on-usergw.opennet_ugw${1}.mtu_msg=$status_output"
		uci -q set "on-usergw.opennet_ugw${1}.mtu_toGW_tried=$toGW_tried"
		uci -q set "on-usergw.opennet_ugw${1}.mtu_toGW_actual=$toGW_actual"
		uci -q set "on-usergw.opennet_ugw${1}.mtu_fromGW_tried=$fromGW_tried"
		uci -q set "on-usergw.opennet_ugw${1}.mtu_fromGW_actual=$fromGW_actual"
		uci -q set "on-usergw.opennet_ugw${1}.mtu_time=$(date +%s)"
		uci -q commit on-usergw
	fi	

	local mtu=$(uci_get on-usergw.opennet_ugw${1}.mtu)
	local mtu_msg=$(uci_get on-usergw.opennet_ugw${1}.mtu_msg)
	msg_debug "$mtu: ugw_checkMTU for ugw${1}, $remote done"
	msg_debug "$mtu: $mtu_msg"
}

#################################################################################
# check all stored Usergateways for working MTU
ugw_checkMTUs () {
	msg_debug "ugw_checkMTUs"
	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do ugw_checkMTU "$nr"; done
}

#################################################################################
# check if route to UGW goes trough WAN. if so, add config
# olsr put's it's routes in a separate table, therefore main table has only locally received routes
# $1=nr
ugw_checkWAN () {
	trap "error_trap ugw_checkWAN $*" $GUARD_TRAPS
	local on_ugw=$(uci_get "on-usergw.opennet_ugw${1}.name")
	local on_ugw_ip=$(query_dns $on_ugw)
	local on_ugw_targetDev
	local wandev
	echo "ugw_checkWAN" >"$DATA_LOCK_FILE"
	# store or remove stored IP
	uci -q set "on-usergw.opennet_ugw${1}.ipaddr=$on_ugw_ip"
	if [ -z "$on_ugw_ip" ]; then
		msg_info "checkWAN: can't resolve $on_ugw, ignoring"
		return
	fi
	on_ugw_targetDev=$(ip route get "$on_ugw_ip" 2>/dev/null | awk '{for (i=1; i<=NF; i++) { if ($i == "dev") print $(i+1); end}}')
	wandev=$(uci_get network.wan.ifname | cut -f1 -d:)
	if [ "$on_ugw_targetDev" = "$wandev" ]; then
		uci -q set "on-usergw.opennet_ugw${1}.wan=ok"
		time=$(ping -w 5 -q $on_ugw_ip 2>/dev/null| awk 'BEGIN{FS="[ \/]+"} /min\/avg\/max/ {print int($7+0.5)}')
		ugw_status set_ugw_flag "$on_ugw_ip" ping "$time"
		msg_debug "checkWAN: $on_ugw routing through wan device: $wandev"
		msg_debug "checkWAN: $on_ugw avg ping time: $time"
	else
		uci -q set "on-usergw.opennet_ugw${1}.wan=error" || true
		ugw_status set_ugw_flag "$on_ugw_ip" ping "$time" ""
	fi
}

#################################################################################
# check all stored Usergateways for working MTU
ugw_checkWANs () {
	local nr
	msg_debug "ugw_checkWANs"
	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do ugw_checkWAN "$nr"; done
}

#################################################################################
# set or search/replace ugw-HNA in olsrd config
# $1 == hna to set for olsr
update_olsr_hna () {
	trap "error_trap update_olsr_hna $*" $GUARD_TRAPS
	local found=""
	local no=0
	local new_section
	msg_debug "update_olsr_hna"
	while [ -n "$(uci_get "olsrd.@Hna4[${no}]")" ]; do
		if [ "$(uci_get "olsrd.@Hna4[${no}].source")" = "ugw" ]; then
			uci -q set "olsrd.@Hna4[${no}].netaddr=$1"
			found=true
			break
		fi
		: $((no++))
	done
	if [ -z "$found" ]; then
		new_section="$(uci add olsrd Hna4)"
		uci set "olsrd.$new_section.netmask=255.255.255.255"
		uci set "olsrd.$new_section.netaddr=$1"
		uci set "olsrd.$new_section.source=ugw"
	fi
	uci commit olsrd
}

#################################################################################
# mark usage of HNA in olsrd config (for removal by cron-daily/clean_ugw_hna.sh)
mark_olsr_hna_used () {
	trap "error_trap mark_olsr_hna_used $*" $GUARD_TRAPS
	msg_debug "mark_olsr_hna_used"
	local no=0
	while ( [ -n "$(uci_get "olsrd.@Hna4[${no}]")" ] ); do
		if [ "$(uci_get "olsrd.@Hna4[${no}].source")" = "ugw" ]; then
			uci set "olsrd.@Hna4[${no}].lastused=$(date +%s)"
			break
		fi
		: $((no++))
	done
	uci commit olsrd
}


#################################################################################
# syncs config from on-usergw to openvpn
ugw_syncVPNConfig () {
	msg_debug "ugw_syncVPNConfig"
	# sync and check VPN config
	lua -e "require('luci.model.opennet.on_usergw_syncconfig') checkVPNConfig()"
}

#################################################################################
# check if sharingInternet is temporarily blocked
ugw_checkSharingBlocked () {
	trap "error_trap ugw_checkSharingBlocked $*" $GUARD_TRAPS
	msg_debug "ugw_checkSharingBlocked"
	local on_share_internet_unblock_time=$(uci_get on-usergw.ugw_sharing.unblock_time)
	[ -z "$on_share_internet_unblock_time" ] && return
	if [ "$(date +%s)" -gt "$on_share_internet_unblock_time" ]; then
		uci_delete on-usergw.ugw_sharing.unblock_time
		uci set on-usergw.ugw_sharing.shareInternet='on'
	elif [ "$(uci_get on-usergw.ugw_sharing.shareInternet)" = "on" ]; then
		uci set on-usergw.ugw_sharing.shareInternet='off'
	fi
}

#################################################################################
# check if sharingInternet is possible for every gateway and
# store 'enabled'-value in openvpn config
ugw_checkWorking () {
	trap "error_trap ugw_checkWorking $*" $GUARD_TRAPS
	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do
		mtu=$(uci_get "on-usergw.opennet_ugw${nr}.mtu") || true
		wan=$(uci_get "on-usergw.opennet_ugw${nr}.wan")
		name=$(uci_get "on-usergw.opennet_ugw${nr}.name")
		gw_name=$(lua -e "require('luci.model.opennet.on_usergw_syncconfig') print(gw_name('${name}'))")

		enable=$(uci_get "openvpn.${gw_name}.enable")

		if [ "$mtu" = "ok" ] && [ "$wan" = "ok" ] && [ "$enable" = "0" ]; then
			uci -q set "openvpn.${gw_name}.enable=1"
			uci commit openvpn
		elif ( [ "$mtu" != "ok" ] || [ "$wan" != "ok" ] ) && [ "$enable" = "1" ]; then
			uci -q set "openvpn.${gw_name}.enable=0"
			uci commit openvpn
		fi
	done
}

#################################################################################
# check if sharingInternet is enabled and tunnels are active or vice versa
ugw_shareInternet () {
	trap "error_trap ugw_shareInternet $*" $GUARD_TRAPS
	msg_debug "ugw_shareInternet"

	sharing="$(uci_get on-usergw.ugw_sharing.shareInternet)"
	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do
		name=$(uci_get "on-usergw.opennet_ugw${nr}.name")
		gw_name=$(lua -e "require('luci.model.opennet.on_usergw_syncconfig') print(gw_name('${name}'))")

		enable=$(uci_get openvpn.${gw_name}.enable)

		if [ ! -e "/var/run/openvpn-${gw_name}.pid" ] && [ "$sharing" = "on" ] && [ "$enable" = "1" ]; then
			msg_debug "activating tunnel ${gw_name}"
			/etc/init.d/openvpn reload
		elif [ -e /var/run/openvpn-${gw_name}.pid ] && ( [ "$sharing" = "off" ] || [ "$enable" = "0" ] ); then
			msg_debug "disabling tunnel ${gw_name}"
			uci -q set "openvpn.${gw_name}.enable=0"
			# reload all OpenVPN sessions. All deactivated sessions will stay down.
			/etc/init.d/openvpn reload
			uci commit openvpn
		fi
	done
}

#################################################################################
# disable ugw forwarding, remove rules from current firewall settings
ugw_disableForward () {
	trap "error_trap ugw_disableForward $*" $GUARD_TRAPS
	msg_debug "ugw_disableForward"
	local uci_prefix
	local src_dport
	local proto
	find_all_uci_sections redirect "src=$ZONE_MESH" | while read uci_prefix; do
		src_dport="$(uci_get "${uci_prefix}.src_dport")"
		proto="$(uci_get "${uci_prefix}.proto")"
		if [ "$src_dport" = "1600" ] || [ "$src_dport" = "123" ] || [ "$src_dport" = "53" ] || [ "$proto" = "icmp" ]; then
			uci_delete "$section"
		fi
	done
	apply_changes firewall
}

#################################################################################
# enable ugw forwarding, add rules from current firewall settings and set hna
# $1 == ip of gateway to forward to
ugw_enableForward () {
	trap "error_trap ugw_enableForward $*" $GUARD_TRAPS
	msg_debug "ugw_enableForward"
	hna=$(lua -e "require('luci.model.opennet.on_hna_check') print(getHNA())")
	section=$(uci add firewall redirect)
	uci set "firewall.$section.src=opennet"
	uci set "firewall.$section.proto=udp"
	uci set "firewall.$section.src_dport=1600"
	uci set "firewall.$section.target=DNAT"
	uci set "firewall.$section.src_dip=$hna"
	uci set "firewall.$section.dest_ip=$1"
	section=$(uci add firewall redirect)
	uci set "firewall.$section.src=opennet"
	uci set "firewall.$section.proto=udp"
	uci set "firewall.$section.src_dport=123"
	uci set "firewall.$section.target=DNAT"
	uci set "firewall.$section.src_dip=$hna"
	uci set "firewall.$section.dest_ip=$1"
	section=$(uci add firewall redirect)
	uci set "firewall.$section.src=opennet"
	uci set "firewall.$section.proto=udp"
	uci set "firewall.$section.src_dport=53"
	uci set "firewall.$section.target=DNAT"
	uci set "firewall.$section.src_dip=$hna"
	# currently DNS-querys are answered by the usergateway Accesspoint DNS
	uci set firewall.$section.dest_ip="$(uci_get olsrd.@olsrd[0].MainIp)"
	# change into thisone if DNS should be forwarded to ugw
	# uci set "firewall.$section.dest_ip=$1"

	section=$(uci add firewall redirect)
	uci set "firewall.$section.src=opennet"
	uci set "firewall.$section.proto=icmp"
	uci set "firewall.$section.target=DNAT"
	uci set "firewall.$section.src_dip=$hna"
	uci set "firewall.$section.dest_ip=$(uci_get olsrd.@olsrd[0].MainIp)"
	apply_changes firewall
	update_olsr_hna "$hna"
	announce_olsr_service_ugw "$hna"
	msg_info "ugw_enableForward restarting olsrd"
	# TODO: was hat olsrd hier zu tun?
	/etc/init.d/olsrd restart >/dev/null
}

#################################################################################
# check is done every 5 minutes, if there is a better gw then switch
ugw_forwardGW () {
	trap "error_trap ugw_forwardGW $*" $GUARD_TRAPS
	msg_debug "ugw_forwardGW"
	local found_first_ugw
	local better_ugw_count
	local ugw_ipaddr
	local name
	local ugw_name
	local ugw_enabled
	local ugw_possible
	local sharing=$(uci_get on-usergw.ugw_sharing.shareInternet)
	local current_ugw_ipaddr=$(get_ugw_portforward | cut -f 2)

	if [ "$sharing" != "on" ]; then
		ugw_disableForward
		return
	fi

	mark_olsr_hna_used

	found_first_ugw=
	better_ugw_count=$(uci_get on-usergw.ugw_sharing.better_ugw)

	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do
		ugw_ipaddr="$(uci_get "on-usergw.opennet_ugw${nr}.ipaddr")"
		name=$(uci_get "on-usergw.opennet_ugw${nr}.name")
		ugw_name=$(lua -e "require('luci.model.opennet.on_usergw_syncconfig') print(gw_name('${name}'))")
		ugw_enabled="$(uci_get "openvpn.${ugw_name}.enable")"
		ugw_possible=$(get_ugw_value "$ugw_ipaddr" status)

		# it is not working
		[ -z "$ugw_enabled" ] && continue

		# this gateway connection is not usable
		[ "$ugw_possible" != "y" ] && continue

		# we found one before (why not look for another?)
		[ -n "$found_first_ugw" ] && continue

		# try if this gateway is better than the currently active one
		msg_debug "checking first found usergw - $ugw_ipaddr"
		if [ "$ugw_ipaddr" != "$current_ugw_ipaddr" ]; then
			msg_debug "first found usergw - $ugw_ipaddr != $current_ugw_ipaddr"
			if [ -z "$current_ugw_ipaddr" ] || [ $((better_ugw_count+5)) -gt "$betterusergateway_timeout" ]; then
				msg_info "found a better usergateway, changing to $ugw_ipaddr"
				ugw_disableForward
				ugw_enableForward "$ugw_ipaddr"
				better_ugw_count=0
			fi
			uci -q set "on-usergw.ugw_sharing.better_ugw=$better_ugw_count"
		else
			msg_debug "first found gw - $ugw_ipaddr == $current_ugw_ipaddr"
			uci -q set on-usergw.ugw_sharing.better_ugw=0
		fi
		found_first_ugw=true
	done
	# disable forward if no working gateway was found at all
	[ -z "$found_first_ugw" ] && ugw_disableForward
	return
}

#################################################################################
# do extra checks (speed, mtu) only at dedicated times
ugw_doExtraChecks () {
	trap "error_trap ugw_doExtraChecks $*" $GUARD_TRAPS
	msg_debug "ugw_doExtraChecks"
	local nr
	local speed_time
	local name
	local gw_name
	local vpn_pid
	local mtu_time
	local restart_time=$(($(date +%s)-$(cut -f1 -d. /proc/uptime)))

	for nr in $(get_prefixed_items 'on-usergw.opennet_ugw'); do
		# do extraChecks only if WAN-Connection is established
		[ "$(uci_get "on-usergw.opennet_ugw${nr}.wan")" != "ok" ] && continue

		# speedCheck
		speed_time=$(uci_get "on-usergw.opennet_ugw${nr}.speed_time")
		[ -z "$speed_time" ] && speed_time=0
		# never checked since restart
		if [ "$((speed_time-restart_time))" -lt 0 ]; then
			uci -q set "on-usergw.opennet_ugw${nr}.speed_time="
			uci -q set "on-usergw.opennet_ugw${nr}.speed_time_prev="
		fi
		speed_time=$(uci_get "on-usergw.opennet_ugw${nr}.speed_time")
		speed_time_prev=$(uci_get "on-usergw.opennet_ugw${nr}.speed_time_prev")
		if [ -z "$speed_time" ] ||
				# last (successful) check older than 1 day and no two successful checks had been done
				( [ "$(($(date +%s)-speed_time))" -gt 86400 ] && [ -z "$speed_time_prev" ] ); then
			ugw_checkSpeed "$nr"
		fi

		# mtuCheck
		# if last mtucheck is older than 1 day and ugw is not running
		name=$(uci_get "on-usergw.opennet_ugw${nr}.name")
		gw_name=$(lua -e "require('luci.model.opennet.on_usergw_syncconfig') print(gw_name('${name}'))")
		vpn_pid=$(cat "/var/run/openvpn-${gw_name}.pid" 2>/dev/null)
		mtu_time=$(uci_get "on-usergw.opennet_ugw${nr}.mtu_time")
		([ -z "$vpn_pid" ] || [ ! -d "/proc/$vpn_pid" ]) && [ "$(($(date +%s)-mtu_time))" -gt 86400 ] && ugw_checkMTU "$nr"
	done
}

#################################################################################
# values are equal to minutes (check is usually done every 5 minutes)
# time after the gateway is switched when found not working in minutes
betterusergateway_timeout=$(get_on_usergw_default vpn_bettergateway_timeout)

# after how many times gateway-vpn-function should rechecked
recheck_age=$(get_on_usergw_default vpn_recheck_age)

# how often it will be tried to establish a connection till gateway is declared as not to work
nonworking_timeout=$(get_on_usergw_default vpn_nonworking_timeout)

#################################################################################
# start here - with the menu
ACTION="${1:-auto}"
shift

test "$ACTION" = "--help" && echo -e "\
Usage: on_usergateway_check [OPTION]...
	usually called by cron every 5 minutes
Options:
	(no option)	do regular 5-minutely check
	syncVPNConfig	transfer UGW config from on-usergw to openvpn
	checkWan	check if routes to UGW go through WAN-device, detect ping-time
	checkMtu	check if MTU of WAN-UGW-Tunnel is ok
			this test will last ~5 minutes per tunnel
			results will be stored in on-usergw config
	checkVpn	check Vpn availability of gateway on port 1600
	checkSpeed	check Speed of Gateway
	shareInternet	start UGW-tunnels if MTU and WAN ok and sharing is enabled
	--help		this help" && exit 0

aquire_lock "$DATA_LOCK_FILE" 600 || { msg_debug "parallel instance running, exit" && exit; }
echo "running" >"$DATA_LOCK_FILE"
msg_debug "starting another instance ($@)"


case "$ACTION" in
	"syncVPNConfig")	ugw_syncVPNConfig;;
	"checkWan")		if [ $# -gt 0]; then ugw_checkWAN "$@"; else ugw_checkWANs; fi;;
	"checkMtu")		if [ $# -gt 0]; then ugw_checkMTU "$@"; else ugw_checkMTUs; fi;;
	"checkVpn")		if [ $# -gt 0]; then ugw_checkVPN "$@"; else ugw_checkVPNs; fi;;
	"checkSpeed")		if [ $# -gt 0]; then ugw_checkSpeed "$@"; else ugw_checkSpeeds; fi;;
	"shareInternet")
		ugw_checkSharingBlocked
		ugw_checkWorking
		ugw_forwardGW
		ugw_shareInternet
		;;
	auto|*)
		cert_file=$(uci_get on-usergw.opennet_ugw.cert)
		if [ -e "$cert_file" ]; then
			ugw_syncVPNConfig
			ugw_checkWANs
			ugw_checkVPNs
			ugw_doExtraChecks
			ugw_checkSharingBlocked
			ugw_checkWorking
			ugw_forwardGW
			ugw_shareInternet
		 else
			msg_debug "skipping UGW checks (no certificate found: $cert_file)"
		 fi
		;;
esac

#################################################################################
# commit changes, otherwise they will slow down the whole system significantly
uci commit on-usergw

rm -f "$DATA_LOCK_FILE"
msg_debug "finishing another instance"

