#!/usr/bin/micropython
#
# Ermittle die Anzahl der Nutzertunnel, die durch eine UGW-AP verlaufen.
# Die Verbindungen werden anhand von nf_conntrack ermittelt.
#

import os
import sys


# dieser Port auf dem externen UGW-Server wird als Erkennungsmerkmal fuer Nutzertunnel-Verbindungen verwendet
UGW_SERVER_PORT = 1600
UGW_SERVER_PROTOCOL = "udp"
# minimale Anzahl von Paketen, um eine Test-Verbindung von einer echten Verbindung zu unterschieden
UGW_CONNECTION_MIN_PACKETS = 100


def get_fieldname(text):
    result = []
    for char in text.lower():
        if not (('a' <= char <= 'z') or ('0' <= char <= '9')):
            char = "_"
        result.append(char)
    return "".join(result)


def get_connections_by_target():
    def parse_assignments(tokens):
        try:
            result = {key: value for key, value in [token.split("=", 1) for token in tokens]}
        except ValueError:
            # fehlende Zuordnung ("=")
            return None
        for key in ("sport", "dport", "packets", "bytes"):
            try:
                result[key] = int(result[key])
            except KeyError:
                return None
        return result
    target_connections = {}
    with open("/proc/net/nf_conntrack", "r") as conntrack_file:
        for line in conntrack_file.readlines():
            """ example line (splitted):
                    ipv4     2 udp      17 176
                    src=192.168.2.155 dst=192.168.2.254 sport=53231 dport=5100 packets=16613 bytes=1876140
                    src=62.141.37.125 dst=172.16.241.254 sport=1600 dport=53231 packets=26214 bytes=3956803
                    [ASSURED] use=2
            """
            tokens = line.split()
            protocol = tokens[2]
            if protocol != UGW_SERVER_PROTOCOL:
                continue
            forward_tokens = tokens[5:][:6]
            backward_tokens = tokens[11:][:6]
            forward = parse_assignments(forward_tokens)
            backward = parse_assignments(backward_tokens)
            if not forward or not backward:
                # fehlende forward/backwards-Informationen
                continue
            if backward["sport"] != UGW_SERVER_PORT:
                continue
            # Test-Verbindungen ignorieren
            if forward["packets"] < UGW_CONNECTION_MIN_PACKETS:
                continue
            # es ist eine echte Nutzertunnel-Verbindung
            if not backward["src"] in target_connections:
                target_connections[backward["src"]] = {"count": 1}
            else:
                target_connections[backward["src"]]["count"] += 1
    for key in target_connections:
        target_connections[key]["label"] = key
        target_connections[key]["fieldname"] = "host_" + get_fieldname(key)
    return sorted(target_connections.values(), key=lambda item: item["label"])


if __name__ == "__main__":
    if len(sys.argv) > 1:
        if sys.argv[1] == "config":
            connections = get_connections_by_target()
            print("graph_title Verbindungen ueber freigegebenen Anschluss")
            print("graph_args --base 1000")
            print("graph_vlabel Number of connections")
            print("graph_category opennet")
            is_first = True
            for target in connections:
                print("{fieldname}.label {label}".format(**target))
                print("{0}.draw {1}".format(target["fieldname"], ("AREA" if is_first else "STACK")))
                is_first = False
            sys.exit(0)
        elif sys.argv[1] == "":
            pass
        else:
            # unknown argument
            message = "Unknown argument"
            linesep = getattr(os, "linesep", "\n")
            sys.stderr.write(message + linesep)
            sys.exit(1)

    connections = get_connections_by_target()
    for target in connections:
        print("{fieldname}.value {count}".format(**target))
