#!/bin/sh
#
# Opennet Firmware
#
# Copyright 2010 Rene Ejury <opennet@absorb.it>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# 	http://www.apache.org/licenses/LICENSE-2.0
#


# include helper functions
. "${IPKG_INSTROOT:-}/usr/bin/on-helper.sh"


PID_FILE=/var/run/on_vpngateway_check.pid
VPN_DIR=/etc/openvpn/opennet_user


# do not run if there is no certificate and no key
if ! [ -e "$VPN_DIR/on_aps.crt" ] || ! [ -e "$VPN_DIR/on_aps.key" ]; then
	msg_debug "no VPN certificate or key found: $VPN_DIR/on_aps.(crt|key) -> exiting"
	exit 0
fi

#################################################################################
# initialization to prevent two instances running at the same time
# If interrupted, remove pid-file and set a mark in log
USER_INTERRUPT=13
trap "rm -f $PID_FILE; logger -t on_vpngateway_check[$$] was killed by another instance; exit $USER_INTERRUPT" TERM INT

msg_debug "starting another instance ($@)"
# echo "starting another instance"
# check if other instance is running, if yes, kill other instance
if [ -f "$PID_FILE" ]; then
	msg_debug "detected '$PID_FILE'"
	# remove pid file is process is finished
	kill "$(cat "$PID_FILE")" 2>/dev/null || rm "$PID_FILE"
fi

# register that process is running
# wait till other process is finished
limit=30 # number of seconds to wait at most till other instance is finished.
counter=0
while [ -f "$PID_FILE" ]; do
	[ "$counter" -eq 0 ] && msg_debug "sleeping until other instance is finished"
	sleep 1
	counter=$((counter+1))
	if [ "$counter" -ge "$limit" ]; then
		msg_debug "other instance doesn't finished in time, aborting"
		exit
	fi
done
echo "$$" >"$PID_FILE"
#################################################################################


#################################################################################
# search all available gateways by criteria defined in on-openvpn.@gateways[0].vpn_sort_criteria
# and sort them dependent on their ETX or Metric distance
gateway_autosearch()
{
	activate_olsr_service
	
	# only do this if explicitely requested (param refresh) or activated in config
	if [ "${1:-}" != "refresh" ] && [ "$(uci -q get on-openvpn.@gateways[0].autosearch)" != "on" ]; then return; fi
	
	# it's now done in lua, because it's easier with associative arrays
	lua "${IPKG_INSTROOT:-}/usr/lib/lua/luci/model/opennet/on_vpn_autosearch.lua"
}

#################################################################################
# check olsrd config for activated nameservice plugin
# if not found activate, required for speed of gateways
activate_olsr_service () {
	local found=""
	local nr=0
	while ( [ -n "$(uci -q get "olsrd.@LoadPlugin[$nr]")" ] ); do
		[ "$(uci -q get "olsrd.@LoadPlugin[$nr].library" | cut -d. -f1)" = "olsrd_nameservice" ] && return
		: $((nr++))
	done

	new_section="$(uci add olsrd LoadPlugin)"
	uci set "olsrd.$new_section.library=olsrd_nameservice.so.0.3"
	uci commit olsrd
	/etc/init.d/olsrd restart >/dev/null
}

#################################################################################
# try to establish openvpn tunnel
# return a string, if it works (else return nothing)
# parameter is index to test
test_vpngateway()
{
	local uci_prefix=on-openvpn.gate_$1
	local gw_ipaddr=$(uci -q get "$uci_prefix.ipaddr")
	local gw_name=$(uci -q get "$uci_prefix.name")
	local age=$(get_gateway_value "$gw_ipaddr" age)
	if [ -n "$age" ] && [ "$age" -ge $((recheck_age+nonworking_timeout)) ]; then
		# if there was no vpn-availability for a while (nonworking_timeout minutes), declare vpn-status as not working
		set_gateway_value "$gw_ipaddr" age 0
		set_gateway_value "$gw_ipaddr" status n
		return 1
	elif [ -z "$age" ] || [ "$age" -ge "$recheck_age" ]; then
		if verify_vpn_connection "$gw_ipaddr" "$gw_name" \
				"$VPN_DIR/on_aps.key" \
				"$VPN_DIR/on_aps.crt" \
				"$VPN_DIR/opennet-ca.crt"; then
			set_gateway_value "$gw_ipaddr" age 0
			set_gateway_value "$gw_ipaddr" status y
			msg_debug "vpn-availability of gw $gw_ipaddr successfully tested"
			return 0
		else
			# "age" will grow until it exceeds "recheck_age + nonworking_timeout" -> no need to do anything now
			msg_debug "vpn test of $gw_ipaddr failed"
			return 1
		fi
	elif [ "$(get_gateway_value "$gw_ipaddr" status)" = "y" ]; then
		msg_debug "vpn-availability of gw $gw_ipaddr still valid"
		return 0
	fi
}

#################################################################################
# test if gateway is blacklisted
# side effect: set or remove blacklisting state
# parameter is index to test
# return success (exitcode=0) if blacklisted
check_blacklisting()
{
	local index
	local blacklisted
	local gw_ipaddr=$(uci -q get "on-openvpn.gate_$1.ipaddr")
	# if there is no ipaddr stored then query dns for IP address
	[ -z "$gw_ipaddr" ] && gw_ipaddr=$(query_dns "$(uci -q "get on-openvpn.gate_$1.name")")
	[ -z "$gw_ipaddr" ] && return 1

	blacklisted=$(uci -q get "on-openvpn.gate_$1.blacklisted")
	
	# check if currently checked Gateway is blacklisted, if found then continue in loop
	index=0
	while [ -n "$(uci -q get "on-openvpn.@blacklist_gateway[$index]")" ] ; do
		msg_debug "check_blacklisting $index"
		if [ "$(uci -q get "on-openvpn.@blacklist_gateway[$index].ipaddr")" = "$gw_ipaddr" ]; then
			uci -q set "on-openvpn.gate_$1.blacklisted=true"
			uci commit on-openvpn;		# commit after every change to prevent uci memory problems
			return 0
		fi
		: $((index++))
	done
	
	# gateway was blacklisted before, but not anymore (see early return above)
	if [ -n "$blacklisted" ]; then
		uci -q delete "on-openvpn.gate_$1.blacklisted" || true
		uci commit on-openvpn;			# commit after every change to prevent uci memory problems
	fi
	return 1
}

check_all_blacklisting()
{
	local index=1
	local ipaddr
	while [ -n "$(uci -q get "on-openvpn.gate_$index")" ] ; do
		ipaddr=$(uci -q "get on-openvpn.gate_$index.ipaddr")
		check_blacklisting "$index" && echo "gateway $ipaddr is blacklisted"
		: $((index++))
	done
}

#################################################################################
# test if gateway is blacklisted, set or remove blacklisted option
# parameter is index to test, echo true if blacklisted
check_all_gateways()
{
	local found_first_gw
	local current_gw_ipaddr
	local better_gw_count
	local next_index
	local index
	found_first_gw=
	current_gw_ipaddr=$(uci -q get openvpn.opennet_user.remote)
	better_gw_count=$(uci -q get on-openvpn.@gateways[0].better_gw)
	next_index=1
	while [ -n "$(uci -q get "on-openvpn.gate_$next_index")" ]; do
		index=$next_index
		: $((next_index++))
		gw_ipaddr=$(uci -q get "on-openvpn.gate_$index.ipaddr")

		# if no age set yet than set to recheck_age to force immediate testing
		age=$(get_gateway_value "$gw_ipaddr" age)
		if [ -n "$age" ]; then
			set_gateway_value "$gw_ipaddr" age "$((++age))"
		else
			set_gateway_value "$gw_ipaddr" age "$recheck_age"
		fi

		msg_debug "checking $gw_ipaddr age $age"

		# check if currently checked Gateway is blacklisted, if found then continue in loop
		check_blacklisting "$index" && continue

		msg_debug "         $gw_ipaddr not blacklisted"

		# check if gateway is known to work, else continue in loop
		test_vpngateway "$index" || continue

		msg_debug "         $gw_ipaddr is known to work"

		# if first gateway is not found yet and route to current $gw_ipaddr exists, try if it's better to use this gateway
		if [ -z "$found_first_gw" ] && [ -n "$(ip route show table "$olsrd_routingTable" | awk '$1 == "'$gw_ipaddr'"')" ]; then
			msg_info "checking first found gw - $gw_ipaddr"
			if [ "$gw_ipaddr" != "$current_gw_ipaddr" ]; then
				msg_debug "first found gw - $gw_ipaddr != $current_gw_ipaddr"
				if [ -z "$current_gw_ipaddr" ] || [ $((better_gw_count++)) -gt $bettergateway_timeout ]; then
					msg_info "found a better gateway, changing to $gw_ipaddr"
			
					# set gateway information
					uci -q set "openvpn.opennet_user.remote=$gw_ipaddr"
					vpn_status restart opennet_user
					better_gw_count=0
				fi
				uci -q set "on-openvpn.@gateways[0].better_gw=$better_gw_count"
			else
				msg_debug "first found gw - $gw_ipaddr == $current_gw_ipaddr"
				uci -q set on-openvpn.@gateways[0].better_gw=0
			fi
			found_first_gw='true'
		fi
	done
	# commit after every change to prevent uci memory problems
	uci commit on-openvpn
}

start_stop_openvpn() {
	# stop vpn-tunnel if its not working because route goes trough ugw-tunnel
	# this might be a problem on usergateways: before the ugw-tunnel is working, the user-vpn-gateway is reachable
	# later, if all gateways best reached via the ugw-tunnel, the user-tunnel runs forever complaining about not to work.
	if [ -n "$(ip route show table "$olsrd_routingTable" | awk '/tap/ && $1 == "'$gw_ipaddr'"')" ]; then
		if [ -e "/tmp/openvpn_msg.txt" ]; then
			msg_info "stopping nonworking gateway"
			vpn_status stop opennet_user
			uci -q set on-openvpn.@gateways[0].better_gw=0
			# commit after every change to prevent uci memory problems
			uci commit on-openvpn
		fi
	elif [ -n "$gw_ipaddr" ] && [ ! -e "/var/run/openvpn-opennet_user.pid" ]; then
		sleep 5; # wait a litte while, maybe ntp was updated and time has to be set
		vpn_status start opennet_user
	fi
}

get_gate_ids() {
	uci -q show on-openvpn | grep "^on-openvpn\.gate_[0-9]\+\.ipaddr" | cut -f 2 -d "." | cut -f 2 -d "_"
}

#################################################################################
# check is usually done every minute, therefore values are equal to minutes
# after how many times gateway-vpn-function should rechecked
recheck_age=$(uci -q get on-openvpn.@gateways[0].vpn_recheck_age)
# how often it will be tried to establish a connection till gateway is declared as not to work
nonworking_timeout=$(uci -q get on-openvpn.@gateways[0].vpn_nonworking_timeout)
# how long the current gateway will be kept if a better one is found (small values might result in gateway-flipping)
bettergateway_timeout=$(uci -q get on-openvpn.@gateways[0].vpn_bettergateway_timeout)
# olsrd routing table
olsrd_routingTable=$(uci -q get olsrd.@olsrd[0].RtTable)


case "${1:-}" in
	refresh)
		gateway_autosearch refresh
		;;
	check_blacklisting)
		check_all_blacklisting
		;;
	list)
		vpn_status status
		;;
	test)
		shift
		gw_list=$*
		[ -z "$gw_list" ] && gw_list=$(get_gate_ids)
		for gw_id in $gw_list; do
			gw_addr=$(uci -q get "on-openvpn.gate_$gw_id.ipaddr")
			test -z "$gw_addr" && echo >&2 "Gateway #$gw_id not found" && exit 1
			echo -n "Testing Gateway #$gw_id ($gw_addr): "
			state=$(get_gateway_value "$gw_addr" status)
			# update the age of the gateway to force a test
			if [ "$state" = "y" ]; then
				set_gateway_value "$gw_addr" age "$recheck_age"
			else
				set_gateway_value "$gw_addr" age "$((recheck_age + nonworking_timeout))"
			fi
			test_vpngateway "$gw_id" && echo "OK" || echo "FEHLER"
		 done
		;;
	help|--help)
		echo "Usage: $(basename "$0")  [ACTION] [ARGUMENTS]"
		echo "	refresh:"
		echo "		force refresh of gateway list"
		echo
		echo "	check_blacklisting:"
		echo "		update the 'blacklisted' attribute of all gateways (see on-openvpn.blacklist_gateway)"
		echo
		echo "	list:"
		echo "		show the list of all gateways, their status and the age of their last test"
		echo
		echo "	test [GW_ID [GW_ID [..]]]:"
		echo "		force a test the given gateways (if empty: all gateways) immediately"
		echo
		echo "	/default/:"
		echo "		usually called via cronjob: update gateways, test all gateways and restart openvpn"
		echo
		;;
	*)
		gateway_autosearch
		check_all_gateways
		start_stop_openvpn
		;;
esac


# commit changes, otherwise they will slow down the whole system significantly
# uci commit on-openvpn - already done before

# remove registration
rm -f "$PID_FILE"
msg_debug "finishing another instance"

