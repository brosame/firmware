#!/bin/sh
#
# Opennet Firmware
#
# Copyright 2010 Rene Ejury <opennet@absorb.it>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# 	http://www.apache.org/licenses/LICENSE-2.0
#


# include helper functions
. "${IPKG_INSTROOT:-}/usr/lib/opennet/on-helper.sh"


PID_FILE=/var/run/on_vpngateway_check.pid
OVPN_MSG_FILE=/tmp/openvpn_msg.txt


#################################################################################
# initialization to prevent two instances running at the same time
# If interrupted, remove pid-file and set a mark in log
USER_INTERRUPT=13
trap "rm -f $PID_FILE; logger -t on_vpngateway_check[$$] was killed by another instance; exit $USER_INTERRUPT" TERM INT

# check if other instance is running, if yes, kill other instance (after a grace period for long running processes)
msg_debug "starting another instance ($@)"
clean_stale_pid_file "$PID_FILE"
aquire_lock "$PID_FILE" 3 || { msg_info "older $(basename "$0") process discovered, but it is too young: leaving it alone"; exit 0; }

# register that process is running
# wait till other process is finished
limit=30 # number of seconds to wait at most till other instance is finished.
counter=0
while [ -f "$PID_FILE" ]; do
	[ "$counter" -eq 0 ] && msg_debug "sleeping until other instance is finished"
	sleep 1
	counter=$((counter+1))
	if [ "$counter" -ge "$limit" ]; then
		msg_debug "other instance doesn't finished in time, aborting"
		exit
	fi
	clean_stale_pid_file "$PID_FILE"
done
echo "$$" >"$PID_FILE"
#################################################################################


case "${1:-}" in
	list)
		vpn_status status
		;;
	test)
		shift
		if [ "$#" -gt 0 ]; then
			# filtere die Dienste, die mit der einen angegebene IP assoziiert sind
			get_sorted_services ug ugw | while read service_name; do
				[ "$(get_service_value "$service_name" "host")" = "$1" ] && echo "$service_name"
			done
		else
			get_sorted_services ug ugw | filter_enabled_services
		fi | filter_enabled_services | while read service_name; do
			description=$(get_service_description "$service_name")
			echo "Testing Gateway: $description"
			# forciere den Test durch Loeschen des Zeitstempels
			set_service_value "$service_name" "timestamp_connection_test" ""
			test_mig_connection "$service_name" && echo "OK" || echo "FEHLER"
			# positives Ende
			true
		 done
		exit 0
		find_and_select_best_gateway
		;;
	help|--help)
		echo "Usage: $(basename "$0")  [ACTION] [ARGUMENTS]"
		echo "	list:"
		echo "		show the list of all gateways, their status and the age of their last test"
		echo
		echo "	test [GW_ID [GW_ID [..]]]:"
		echo "		force a test the given gateways (if empty: all gateways) immediately"
		echo
		echo "	/default/:"
		echo "		usually called via cronjob: update gateways, test all gateways and restart openvpn"
		echo
		;;
	auto|*)
		# teste alle VPN-Verbindungen (falls noetig und moeglich)
		get_sorted_services ug ugw | filter_enabled_services | while read service_name; do
			test_mig_connection "$service_name" || true
		done
		# die Gateway-Auswahl ist nur relevant, falls ein Schluessel vorhanden ist
		if ! [ -e "$MIG_VPN_DIR/on_aps.crt" ] || ! [ -e "$MIG_VPN_DIR/on_aps.key" ]; then
			msg_debug "no VPN certificate or key found: $MIG_VPN_DIR/on_aps.(crt|key) -> exiting"
			exit 0
		fi
		find_and_select_best_gateway
		;;
esac

# remove registration
rm -f "$PID_FILE"
msg_debug "finishing another instance"

