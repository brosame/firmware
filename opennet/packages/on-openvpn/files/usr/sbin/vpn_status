#!/bin/sh
#
# Opennet Firmware
#
# Copyright 2010 Rene Ejury <opennet@absorb.it>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# 	http://www.apache.org/licenses/LICENSE-2.0
#

# include helper functions
. "${IPKG_INSTROOT:-}/usr/lib/opennet/on-helper.sh"

print_status()
{
	local current_gw
	local service_name
	local host
	local age
	local status
	local timestamp
	local active
	local offset
	local quality
	local now
	local sorting
	local format_string
	now=$(get_uptime_minutes)
	sorting=$(get_service_sorting)
	format_string="%6s %-16s %18s %7s %4s\n"

	printf "$format_string" "active" "IP" "Quality" "VPN" "Age"
	get_services "gw" | sort_services_by_priority | while read service_name; do
		host=$(get_service_value "$service_name" "host")
		if uci_is_true "$(get_service_value "$service_name" "disabled" "false")"; then
			# der Dienst wird ignoriert
			printf "$format_string" "" "$host" "disabled" "" ""
		elif [ -z "$(get_service_value "$service_name" "distance")" ]; then
			# der Dienst ist nicht erreichbar
			printf "$format_string" "" "$host" "unreachable" "" ""
		else
			# der Dienst wurde nicht abgeschaltet
			timestamp=$(get_service_value "$service_name" "status_timestamp")
			if [ -n "$timestamp" ]; then
				age=$((now-timestamp))
			else
				age=
			fi
			status=$(get_service_value "$service_name" "status")
			if [ "$sorting" = "hop" -o "$sorting" = "etx" ]; then
				offset=$(get_service_value "$service_name" "offset")
				quality=$(get_distance_with_offset "$service_name")
				[ -z "$offset" ] && offset=0
				[ "$offset" -gt 0 ] && offset="+$offset"
				[ "$offset" -ne 0 ] && quality="($offset) $quality"
			elif [ "$sorting" = "manual" ]; then
				quality=$(get_service_value "$service_name" "rank")
			fi
			# Begrenzung auf eine Nachkommastalle
			quality=$(printf "%.1f" "$quality")
			connection_state=$(get_openvpn_service_state "$service_name")
			if [ "$connection_state" = "active" ]; then
				active="*"
			elif [ "$connection_state" = "connecting" ]; then
				active="?"
			else
				active=""
			fi
			printf "$format_string" "$active" "$host" "$quality" "$status" "$age"
		fi
	done
}


print_usage()
{
	echo
	echo "*** vpn_status supports the following actions: ***"
	echo "add_gw IP [PORT] - manually add a gateway"
	echo "move_top IP      - move a gateway to the top of the priority list"
	echo "move_up IP       - move a gateway one step up"
	echo "move_down IP     - move a gateway one step down"
	echo "status           - show all VPN gateways and their status"
	echo "start            - start the VPN tunnel"
	echo "stop             - stop the VPN tunnel"
	echo "restart          - restart the VPN tunnel"
}


_get_gateway_service_from_ip() {
	local host="$1"
	get_services "gw" | filter_services_by_value "host" "$host" | tail -1
}


# Bewege ein Gateway in der Liste
move_top()	{ move_service_top	"$1" "gw"; }
move_up()	{ move_service_up	"$1" "gw"; }
move_down()	{ move_service_down	"$1" "gw"; }


add_gw() {
	trap "error_trap add_gw '$*'" $GUARD_TRAPS
	local ipaddr="$1"
	local port="${2:-$DEFAULT_MIG_PORT}"
	notify_service "gw" "openvpn" "$ipaddr" "$port" "udp" "/" "manual" >/dev/null
}


ACTION=help
[ $# -ge 1 ] && ACTION=$1

case "$ACTION" in
	move_top|move_up|move_down)
		[ $# -ne 2 ] && echo >&2 "ERROR: '$ACTION' requires one more parameter" && exit 1
		host="$2"
		service_name=$(_get_gateway_service_from_ip "$host")
		if [ -n "$service_name" ]; then
			"$ACTION" "$service_name"
		else
			echo >&2 "No gateway service related to host '$host' found."
		fi
	;;
	add_gw)
		[ $# -ge 2 ] && echo >&2 "ERROR: '$ACTION' requires one more parameter" && exit 1
		shift
		# Uebergabeparameter sind der Hostname und (optional) der Port
		"$ACTION" "$@"
	;;
	status)
		print_status
	;;
	start|stop|restart)
		# leider ist diese Funktion etwas grob: eventuell koennen mehr Instanzen beeinflusst werden, als gewollt
		/etc/init.d/openvpn "$ACTION"
	;;
	help|--help)
		print_usage
	;;
	*)
		print_usage >&2
		exit 1
	;;
esac

exit 0

