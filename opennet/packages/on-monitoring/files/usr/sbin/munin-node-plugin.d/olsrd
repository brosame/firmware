#!/bin/sh
# weird shebang? See below "BAD AND UGLY" ...
#
# Collect basic information about the neighbours of an OLSR node:
#   * link quality
#   * neighbour link quality
#   * number of nodes reachable behind this neighbour
#
# Magic markers
#%# capabilities=autoconf
#%# family=auto

"""true"
# ****************** BAD AND UGLY ***************
# This unbelievable dirty hack allows us to run micropython with additional startup options.
# This is necessary due to our demand for more than 128k heap (this default is sufficient for only 400 olsr nodes).
# This "execution hack" works as follows:
#   * the script is executed by busybox ash
#   * the above line (three quotes before and one quote after 'true') evaluates differently for shell and python:
#    * shell: run "true" (i.e. nothing happens)
#    * python: ignore everything up to the next three consecutive quotes
# This hack would not be necessary if busybox's ash would handle shebang arguments properly.

/usr/bin/micropython -X heapsize=512k "$0" "$@"
exit $?
"""


plugin_version = "0.2"


import os
import socket
import sys


LQ_GRAPH_CONFIG = """
graph_title     {title}
graph_vlabel    Link Quality (-) / Neighbour Link Quality (+)
graph_category  network
graph_info      OLSR estimates the quality of a connection by the ratio of successfully received (link quality) and transmitted (neighbour link quality) hello packets.
"""

LQ_VALUES_CONFIG = """
nlq{suffix}.label none
nlq{suffix}.type GAUGE
nlq{suffix}.graph no
nlq{suffix}.draw {draw_type}
nlq{suffix}.min 0
lq{suffix}.label {label}
lq{suffix}.type GAUGE
lq{suffix}.draw {draw_type}
lq{suffix}.negative nlq{suffix}
lq{suffix}.min 0
"""

NEIGHBOUR_COUNT_CONFIG = """
graph_title     Reachable nodes via neighbours
graph_vlabel    Number of Nodes
graph_category  network
graph_info      Count the number of locally known routes passing through each direct neighbour. This number is a good approximation of the number of mesh nodes reachable via this specific neighbour. MIDs (alternative addresses of an OLSR node) and HNAs (host network announcements) are ignored.
"""

NEIGHBOUR_COUNT_VALUE = """
neighbour_{host_fieldname}.label = {host}
neighbour_{host_fieldname}.type = GAUGE
neighbour_{host_fieldname}.draw = {draw_type}
neighbour_{host_fieldname}.min = 0
"""


get_clean_fieldname = lambda name: "".join([(("a" <= char.lower() <= "z") or ((index == 0) or ("0" <= char <= "9"))) and char or "_" for index, char in enumerate(name)])


def query_olsrd_txtservice(section=""):
    host = os.getenv("olsrd_host", "localhost")
    port = os.getenv("olsrd_port", "2006")
    conn = socket.create_connection((host, port), 1.0)
    conn.sendall("/%s" % section)
    fconn = open(conn.fileno(), "r")
    # "enumerate" is not suitable since it reads all lines at once (not a generator in micropython)
    index = 0
    for line in fconn.readlines():
        # skip the first five lines - they are headers
        if index < 5:
            index += 1
            continue
        line = line.strip()
        if line:
            yield line
    fconn.close()
    conn.close()


def get_address_device_mapping():
    mapping = {}
    for line in query_olsrd_txtservice("mid"):
        # example line content:
        #    192.168.2.171   192.168.22.171;192.168.12.171
        device_id, mids = line.split()
        for mid in mids.split(";"):
            mapping[mid] = device_id
    return mapping


def count_routes_by_neighbour(address_mapping, ignore_list):
    node_count = {}
    for line in query_olsrd_txtservice("routes"):
        # example line content:
        #    192.168.1.79/32 192.168.12.38   4       4.008   wlan0
        tokens = line.split()
        target = tokens[0]
        via = tokens[1]
        # we care only about single-host routes
        if target.endswith("/32"):
            if target[:-3] in address_mapping:
                # we ignore MIDs - we want only real nodes
                continue
            if target in ignore_list:
                continue
            # replace the neighbour's IP with its main IP (if it is an MID)
            via = address_mapping.get(via, via)
            # increase the counter
            node_count[via] = node_count.get(via, 0) + 1
    return node_count


def get_olsr_links():
    mid_mapping = get_address_device_mapping()
    hna_list = [line.split()[0] for line in query_olsrd_txtservice("hna")]
    route_count = count_routes_by_neighbour(mid_mapping, hna_list)
    for line in query_olsrd_txtservice("links"):
        tokens = line.split()
        link = {}
        link["local"] = tokens.pop(0)
        remote = tokens.pop(0)
        # replace the neighbour's IP with its main IP (if it is an MID)
        link["remote"] = mid_mapping.get(remote, remote)
        for key in ("hysterese", "lq", "nlq", "cost"):
            link[key] = float(tokens.pop(0))
        # add the route count
        link["route_count"] = route_count.get(link["remote"], 0)
        yield link


if __name__ == "__main__":
    # parse arguments
    if len(sys.argv) > 1:
        if sys.argv[1]=="config":
            links = list(get_olsr_links())

            # link quality with regard to neighbours
            print("multigraph olsr_link_quality")
            print(LQ_GRAPH_CONFIG.format(title="OLSR Link Quality"))
            is_first = True
            for link in links:
                print(LQ_VALUES_CONFIG.format(label=link["remote"],
                                              suffix="_{host}".format(host=get_clean_fieldname(link["remote"])),
                                              draw_type=("AREA" if is_first else "STACK")))
                print()
                is_first = False
            is_first = True
            for link in links:
                print("multigraph olsr_link_quality.host_{remote}".format(remote=get_clean_fieldname(link["remote"])))
                print(LQ_GRAPH_CONFIG.format(title="Link Quality towards {host}".format(host=link["remote"])))
                print(LQ_VALUES_CONFIG.format(label="Link Quality", suffix="", draw_type=("AREA" if is_first else "STACK")))
                print()
                is_first = False

            # link count ("number of nodes behind each neighbour")
            print("multigraph olsr_neighbour_link_count")
            is_first = True
            for link in links:
                print(NEIGHBOUR_COUNT_VALUE.format(host=link["remote"],
                                                   host_fieldname=get_clean_fieldname(link["remote"]),
                                                   draw_type=("AREA" if is_first else "STACK")))
                is_first = False

            sys.exit(0)
        elif sys.argv[1] == "autoconf":
            if os.path.exists(os.getenv('olsrd_path', '/usr/sbin/olsrd')):
                print('yes')
            else:
                print('no')
            sys.exit(0)
        elif sys.argv[1] == "version":
            print('olsrd Munin plugin, version %s' % plugin_version)
            sys.exit(0)
        elif sys.argv[1] == "":
            # ignore
            pass
        else:
            # unknown argument
            print("Unknown argument", file=sys.stderr)
            sys.exit(1)

    # output values
    links = list(get_olsr_links())
    print("multigraph olsr_link_quality")
    for link in links:
        print("lq_{remote}.value {lq:f}".format(lq=link["lq"], remote=get_clean_fieldname(link["remote"])))
        print("nlq_{remote}.value {nlq:f}".format(nlq=link["nlq"], remote=get_clean_fieldname(link["remote"])))
        print()
    for link in links:
        print("multigraph olsr_link_quality.host_{remote}".format(remote=get_clean_fieldname(link["remote"])))
        print("lq.value {lq:f}".format(lq=link["lq"]))
        print("nlq.value {nlq:f}".format(nlq=link["nlq"]))
        print()

    print("multigraph olsr_neighbour_link_count")
    for index, link in enumerate(links):
        print("neighbour_{host_fieldname}.value {value}".format(value=link["route_count"],
                                                                host_fieldname=get_clean_fieldname(link["remote"])))
