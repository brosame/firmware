#!/bin/sh
#
# Konfiguriere uebliche Opennet-Interfaces sowie ein lokales Interface.
#
# Dieses Skript wird nur ein einziges Mal nach einem Upgrade oder der Erstinstallation ausgefuehrt:
#   http://wiki.openwrt.org/doc/uci#defaults
#

set -eu


. "${IPKG_INSTROOT:-}/usr/lib/opennet/on-helper.sh"


configure_opennet_zone() {
	local uci_prefix=$(find_first_uci_section firewall zone "name=$ZONE_MESH")
	# Zone existiert? Keine Aenderungen ...
	[ -n "$uci_prefix" ] && return 0
	uci_prefix=firewall.$(uci add firewall zone)
	uci set "$uci_prefix=zone"
	uci set "$uci_prefix.name=$ZONE_MESH"
	# Opennet-APs bieten ueblicherweise keine privaten Dienste an
	uci set "$uci_prefix.input=ACCEPT"
	# ausgehende Pakete sind OK
	uci set "$uci_prefix.output=ACCEPT"
	# Verkehr aus dem opennet-Netz darf nicht in lokale oder tunnel-Netze
	uci set "$uci_prefix.forward=REJECT"
	# via "masq_src" ersetzen wir die ehemalige "/etc/firewall.opennet" fuer Quell-basiertes Masquerading
	add_zone_forward local "$ZONE_MESH"
	update_opennet_zone_masquerading
}


configure_olsr_radio() {
	trap "error_trap configure_olsr_radio $*" $GUARD_TRAPS
	local iface_index=$1
	local iface_logical=$2
	local iface_phys=$3

	local uci_wifi=wireless.@wifi-iface[$iface_index]
	local uci_radio=wireless.$(uci_get "${uci_wifi}.device")
	local radio_hwmode=$(uci_get "${uci_radio}.hwmode")

	uci set "${uci_wifi}.network=$iface_logical"
	uci set "${uci_wifi}.ifname=$iface_phys"

	uci set "wireless.radio${iface_index}.country=$(get_on_core_default wifi_country)"
	uci_delete "wireless.radio${iface_index}.disabled"

	# typ-spezifische Attribute
	if echo "$radio_hwmode" | grep -q "a"; then
		# 5 GHz: kein Mesh-Modus verfuegbar
		uci set "${uci_wifi}.ssid=$(get_on_core_default wifi_ssid_5ghz)"
		uci set "${uci_wifi}.mode=$(get_on_core_default wifi_mode_5ghz)"
		uci set "${uci_radio}.channel=$(get_on_core_default wifi_channel_5ghz)"
		uci set "${uci_wifi}.isolate=1"
	else
		# 2,4 GHz: Ad-hoc-Modus
		uci set "${uci_wifi}.ssid=$(get_on_core_default wifi_ssid)"
		uci set "${uci_wifi}.mode=$(get_on_core_default wifi_mode)"
		[ -n "$wifi_bssid" ] && uci set "${uci_wifi}.bssid=$(get_on_core_default wifi_bssid)"
		uci set "${uci_radio}.channel=$(get_on_core_default wifi_channel)"
	fi
	return
}


configure_olsr_single_interface() {
	trap "error_trap configure_olsr_single_interface $*" $GUARD_TRAPS
	local iface_logical=$1
	local iface_addr=$2
	local iface_netmask=$3
	local iface_phys=$4

	# configure on_wifi
	uci set "network.${iface_logical}=interface"
	uci set "network.${iface_logical}.proto=static"
	uci set "network.${iface_logical}.ifname=$iface_phys"
	uci set "network.${iface_logical}.netmask=$iface_netmask"
	uci set "network.${iface_logical}.defaultroute=0"
	uci set "network.${iface_logical}.peerdns=0"
	uci set "network.${iface_logical}.ipaddr=$iface_addr"

	# disable dhcp on on_wifi
	uci set "dhcp.${iface_logical}=dhcp"
	uci set "dhcp.${iface_logical}.interface=${iface_logical}"
	uci set "dhcp.${iface_logical}.dynamicdhcp=0"
	uci set "dhcp.${iface_logical}.ignore=1"
}


configure_olsr_interfaces() {
	trap "error_trap configure_olsr_interfaces $*" $GUARD_TRAPS

	# diese Aktion ist bereits abgeschlossen
	uci show network | grep -q "^network\.on_eth_0\." && return 0

	local on_id=$(uci_get on-core.settings.on_id "$(get_on_core_default on_id_preset)")
	local on_ipschema=$(get_on_core_default on_ipschema)
	local on_netmask=$(get_on_core_default on_netmask)
	local on_ipaddr
	local iface_phys
	local iface_logical

	# Suche nach WLAN-Interfaces
	/sbin/wifi detect > /etc/config/wireless

	iface_index=0
	while [ -n "$(uci_get "wireless.@wifi-iface[${iface_index}]")" ]; do
		on_ipaddr=$(get_on_ip "$on_id" "$on_ipschema" "$iface_index")
		iface_phys=wlan$iface_index
		iface_logical=on_wifi_$iface_index

		configure_olsr_single_interface "$iface_logical" "$on_ipaddr" "$on_netmask" "$iface_phys"
		configure_olsr_radio "$iface_index" "$iface_logical" "$iface_phys"

		add_interface_to_zone "$ZONE_MESH" "$iface_logical"

		: $((iface_index++))
	done

	on_ipaddr=$(get_on_ip "$on_id" "$on_ipschema" "$iface_index")
	iface_phys=""
	iface_logical=on_eth_0
	configure_olsr_single_interface "$iface_logical" "$on_ipaddr" "$on_netmask" "$iface_phys"
	add_interface_to_zone "$ZONE_MESH" "$iface_logical"
}


# jede Funktion sollte selbst pruefen, ob ihre Aktion bereits abgeschlossen ist
configure_opennet_zone
configure_olsr_interfaces

# schreibe alle ui-Anederungen
uci commit network
uci commit wireless
uci commit dhcp
uci commit firewall
# loese via procd alle erforderlichen Dienste-Reloads aus
# Fehler duerfen hier passieren
reload_config || true

exit 0

